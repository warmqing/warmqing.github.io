<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="warmqing"><meta name="copyright" content="warmqing"><meta name="google-site-verification" content="r6fMmphB-u3s7p5myuSngUw4xAgHUz0nII5QYBUBG6c"><meta name="baidu-site-verification" content="5cSbHnUUCL"><meta name="sogou_site_verification" content="MF20RUhTSF"><title>Oolong is a happy accident,Serendipity is life | Oolong Box</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-4146880878125243',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a30a198fc71d7b0aa216b4f7f31698a2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"V8UUR9G3TF","apiKey":"5a765edf66f2abc7c0a86abdac87b2de","indexName":"blog_index","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">warmqing</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><nav id="nav" style="background-image: url(https://i.loli.net/2019/04/04/5ca58c8caa281.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Oolong Box</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Oolong Box</div><div id="site-sub-title">Oolong is a happy accident,Serendipity is life</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/warmqing"><i class="fa-github fa"></i></a><a class="social-icon" href="https://warmqing.github.io/atom.xml"><i class="fa-rss fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/box/df0ed28e/">JVM——内存分配与回收策略</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/日志/">日志</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><h1 id="JVM——内存分配与回收策略"><a href="#JVM——内存分配与回收策略" class="headerlink" title="JVM——内存分配与回收策略"></a>JVM——内存分配与回收策略</h1><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h2 id="●-对象优先在-Eden-分配"><a href="#●-对象优先在-Eden-分配" class="headerlink" title="●  对象优先在 Eden 分配"></a>●  对象优先在 Eden 分配</h2><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<h3 id="●-大对象直接进入老年代"><a href="#●-大对象直接进入老年代" class="headerlink" title="●  大对象直接进入老年代"></a>●  大对象直接进入老年代</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<h3 id="●-长期存活的对象进入老年代"><a href="#●-长期存活的对象进入老年代" class="headerlink" title="● 长期存活的对象进入老年代"></a>● 长期存活的对象进入老年代</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h3 id="●-动态对象年龄判定"><a href="#●-动态对象年龄判定" class="headerlink" title="●  动态对象年龄判定"></a>●  动态对象年龄判定</h3><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3 id="●-空间分配担保"><a href="#●-空间分配担保" class="headerlink" title="● 空间分配担保"></a>● 空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<h2 id="Minor-GC-Young-GC、Major-GC-Full-FC"><a href="#Minor-GC-Young-GC、Major-GC-Full-FC" class="headerlink" title="Minor GC/Young GC、Major GC/Full FC"></a>Minor GC/Young GC、Major GC/Full FC</h2><h3 id="●-新生代-GC（Minor-GC-Young-GC）"><a href="#●-新生代-GC（Minor-GC-Young-GC）" class="headerlink" title="● 新生代 GC（Minor GC/Young GC）"></a>● 新生代 GC（Minor GC/Young GC）</h3><p>从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC,因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</p>
<ol>
<li>当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。</li>
<li>内存池被填满的时候，其中的内容全部会被复制，指针会从0开始跟踪空闲内存。Eden 和 Survivor 区进行了标记和复制操作，取代了经典的标记、扫描、压缩、清理操作。所以 Eden 和 Survivor 区不存在内存碎片。写指针总是停留在所使用内存池的顶部。</li>
<li>执行 Minor GC 操作时，不会影响到永久代。从永久代到年轻代的引用被当成 GC roots，从年轻代到永久代的引用在标记阶段被直接忽略掉。</li>
<li>质疑常规的认知，所有的 Minor GC 都会触发“全世界的暂停（stop-the-world）”，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的。其中的真相就 是，大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果正好相反，Eden 区大部分新生对象不符合 GC 条件，Minor GC 执行时暂停的时间将会长很多。</li>
</ol>
<h3 id="●-Minor-GC触发机制："><a href="#●-Minor-GC触发机制：" class="headerlink" title="● Minor GC触发机制："></a>● Minor GC触发机制：</h3><p>当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。</p>
<p>新生代分为一个 Eden区和两个Survivor区的垃圾收集叫做 Minor GC。 清除 Eden 和 from ，转到to中。接下来from与to转换。继续清除 Eden和新from，转到to。清除一次后存活超过年龄的 ，转到老年代。to到了阈值后，部分对象转到老年代。</p>
<h3 id="●-老年代-GC（Major-GC-Full-GC）"><a href="#●-老年代-GC（Major-GC-Full-GC）" class="headerlink" title="● 老年代 GC（Major GC / Full GC）"></a>● 老年代 GC（Major GC / Full GC）</h3><p>指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，ParallelScavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程） 。MajorGC 的速度一般会比 Minor GC 慢 10倍以上。</p>
<h3 id="●-Full-GC触发机制："><a href="#●-Full-GC触发机制：" class="headerlink" title="● Full GC触发机制："></a>● Full GC触发机制：</h3><h3 id="（1）调用System-gc"><a href="#（1）调用System-gc" class="headerlink" title="（1）调用System.gc()"></a>（1）调用System.gc()</h3><p>系统建议执行Full GC，但是虚拟机不一定真正去执行，不建议使用这种方式，通过参数-XX:+DisableExplicitGC禁用显式调用System.gc()</p>
<h3 id="（2）老年代空间不足"><a href="#（2）老年代空间不足" class="headerlink" title="（2）老年代空间不足"></a>（2）老年代空间不足</h3><p>大对象直接进入老年代、长期存活的对象进入老年代等，发现老年代空间不足，引起Full GC</p>
<p>通过 -Xmn 调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。</p>
<p>通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<h3 id="（3）方法区空间不足、永久代满"><a href="#（3）方法区空间不足、永久代满" class="headerlink" title="（3）方法区空间不足、永久代满"></a>（3）方法区空间不足、永久代满</h3><p>当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载。</p>
<h3 id="（4）空间分配担保失败"><a href="#（4）空间分配担保失败" class="headerlink" title="（4）空间分配担保失败"></a>（4）空间分配担保失败</h3><p>Minor GC 之前，即Eden区满时，可触发空间分配担保，参考空间分配担保机制，老年代的可用内存小于历次通过Minor GC后进入老年代的对象的平均大小</p>
<p>由Eden区、survivor space1（From Space）区向survivor space2（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/box/a25844fe/">JVM——类加载机制</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/日志/">日志</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><h1 id="JVM——类加载机制"><a href="#JVM——类加载机制" class="headerlink" title="JVM——类加载机制"></a>JVM——类加载机制</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://i.loli.net/2020/06/16/kC9ieRA86UbpG7B.png" alt="类加载.png"></p>
<p>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><h3 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a>1. 主动引用</h3><p><strong>有且仅有 5 种情况必须立即对类进行“初始化”</strong>：（加载、验证、准备都会随之发生）：</p>
<ul>
<li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li>
</ul>
<p>这 5 种场景中的行为称为对一个类进行<strong>主动引用</strong>，除此之外，所有引用类的方式都不会触发初始化，称为<strong>被动引用</strong>。</p>
<h3 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a>2. 被动引用</h3><ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化。对于静态字段，只有直接定义这个字段的类才会被初始化。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义</span><br></pre></td></tr></table></figure>
<ul>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SuperClass[] sca = new SuperClass[10];</span><br></pre></td></tr></table></figure>
<ul>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ConstClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;ConstClass init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final String HELLO_WORLD = &quot;Hello world&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(ConstClass.HELLO_WORLD);</span><br></pre></td></tr></table></figure>
<p>## </p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int value = 123;</span><br></pre></td></tr></table></figure>
<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final int value = 123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于 byte 类型，默认值为零，即（byte）0。</span><br><span class="line">对于 short 类型，默认值为零，即（short）0。</span><br><span class="line">对于 int 类型，默认值为零，即 0。</span><br><span class="line">对于 long 类型，默认值为零，即 0L。</span><br><span class="line">对于 float 类型，默认值为正零，即 0.0f。</span><br><span class="line">对于 double 类型，默认值为正零，即 0.0d。</span><br><span class="line">对于 char 类型，默认值为空字符，即 &apos;\u0000&apos;。</span><br><span class="line">对于 boolean 类型，默认值为 false。</span><br><span class="line">对于所有引用类型，默认值为 null。</span><br></pre></td></tr></table></figure>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>将常量池的符号引用替换为直接引用的过程。把类中的符号引用转化为直接引用（比如说方法的符号引用，是有方法名和相关描述符组成，在解析阶段，JVM把符号引用替换成一个指针，这个指针就是直接引用，它指向该类的该方法在方法区中的内存位置）</p>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><p>初始化阶段是虚拟机执行类构造器 <clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</clinit></p>
<p>1、<clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</clinit></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        i = 0;                // 给变量赋值可以正常编译通过</span><br><span class="line">        System.out.print(i);  // 这句编译器会提示“非法向前引用”</span><br><span class="line">    &#125;</span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、虚拟机会保证在子类的＜clinit＞（）方法执行之前，父类的＜clinit＞（）方法已经执行完毕。 因此在虚拟机中第一个被执行的＜clinit＞（）方法的类肯定是java.lang.Object。由于父类的＜clinit＞（）方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</p>
<p>3、接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。<strong>注意：接口中的属性都是static final类型的常量，因此在准备阶段就已经初始化。</strong></clinit></clinit></clinit></clinit></p>
<p>4、虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</clinit></clinit></clinit></clinit></p>
<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>把实现类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码模块称为“类加载器”。</p>
<h3 id="1-类的唯一性"><a href="#1-类的唯一性" class="headerlink" title="1.类的唯一性"></a>1.类的唯一性</h3><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。</p>
<p>即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类也不相等。<br>这里所指的“相等”，包括代表类的 Class 对象的 equals() 方法、 isAssignableFrom() 方法、isInstance() 方法的返回结果为true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<h3 id="2-类加载器分类"><a href="#2-类加载器分类" class="headerlink" title="2.类加载器分类"></a>2.类加载器分类</h3><p>类加载器可以划分为：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）,使用 C++ 实现，是虚拟机自身的一部分,负责将存在&lt;JRE_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中.</li>
<li>扩展类加载器（Extension ClassLoader）由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<h3 id="3-双亲委派模型"><a href="#3-双亲委派模型" class="headerlink" title="3.双亲委派模型"></a>3.双亲委派模型</h3><p><img src="https://i.loli.net/2020/06/17/agBy59L36hFN1VW.png" alt="双亲委派类加载器.png"></p>
<p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>双亲委派模型（Parents Delegation Model）, 要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p>
<p>例如类 <code>java.lang.Object</code>，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。</p>
<h3 id="4-ClassLoader-实现双亲委派"><a href="#4-ClassLoader-实现双亲委派" class="headerlink" title="4.ClassLoader 实现双亲委派"></a>4.ClassLoader 实现双亲委派</h3><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载未加载到该类，此时当前类加载器尝试加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class ClassLoader &#123;</span><br><span class="line">    // The parent class loader for delegation</span><br><span class="line">    private final ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        throw new ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">            // First, check if the class has already been loaded</span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                long t0 = System.nanoTime();</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent != null) &#123;</span><br><span class="line">                        c = parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    // ClassNotFoundException thrown if class not found</span><br><span class="line">                    // from the non-null parent class loader</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (c == null) &#123;</span><br><span class="line">                    // If still not found, then invoke findClass in order</span><br><span class="line">                    // to find the class.</span><br><span class="line">                    long t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    // this is the defining class loader; record the stats</span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-自定义类加载器实现"><a href="#5-自定义类加载器实现" class="headerlink" title="5.自定义类加载器实现"></a>5.自定义类加载器实现</h3><p>以下代码中的 MyClassLoader是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器不用重写它，需要重写 findClass() 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        // 加载D盘根目录下指定类名的class</span><br><span class="line">        String clzDir = &quot;D:\\&quot; + File.separatorChar</span><br><span class="line">                + name.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;;</span><br><span class="line">        byte[] classData = getClassData(clzDir);</span><br><span class="line"></span><br><span class="line">        if (classData == null) &#123;</span><br><span class="line">            throw new ClassNotFoundException();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return defineClass(name, classData, 0, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] getClassData(String path) &#123;</span><br><span class="line">        try (InputStream ins = new FileInputStream(path);</span><br><span class="line">             ByteArrayOutputStream baos = new ByteArrayOutputStream()</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            int bufferSize = 4096;</span><br><span class="line">            byte[] buffer = new byte[bufferSize];</span><br><span class="line">            int bytesNumRead = 0;</span><br><span class="line">            while ((bytesNumRead = ins.read(buffer)) != -1) &#123;</span><br><span class="line">                baos.write(buffer, 0, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            return baos.toByteArray();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/box/a9fa83bb/">JVM——内存模型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/日志/">日志</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><h1 id="JVM——内存模型"><a href="#JVM——内存模型" class="headerlink" title="JVM——内存模型"></a>JVM——内存模型</h1><h2 id="JDK6"><a href="#JDK6" class="headerlink" title="JDK6"></a>JDK6</h2><p><img src="https://i.loli.net/2020/06/03/A9fGOk75RK6ezCE.png" alt="jdk6JVM内存模型.png"></p>
<h2 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h2><p><img src="https://i.loli.net/2020/06/03/Xx1caoJfMNwdK59.png" alt="JDK8.jpg"></p>
<p>​                                                   </p>
<h2 id="一、JVM内存模型分类"><a href="#一、JVM内存模型分类" class="headerlink" title="一、JVM内存模型分类"></a>一、JVM内存模型分类</h2><p>JVM内存模型从线程维度归类分为：<strong>线程私有内存</strong>、<strong>线程共享内存</strong>、以及不在堆内的<strong>直接内存</strong>。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><code>直接内存并不是JVM运行时数据区的一部分</code>,在JDK 1.4引入的NIO提供了基于Channel与Buffer的IO方式，它可以使用Native函数库直接分配堆外的内存，然后使用DirectByteBuffer对象作为这块内存的引用进行操作，避免了Java堆和Native堆来回拷贝数据，<code>因此在一些场景中可以显著提高性能。</code></p>
<p><strong>直接内存的分配不会受到Java堆大小的限制</strong>，（即不会遵守-Xms、-Xmx等配置）。但仍然受到本机总内存大小+寻址空间的限制，因此扩展时也会出现<code>OutOfMemoryError</code>异常。</p>
<h3 id="线程私有型内存"><a href="#线程私有型内存" class="headerlink" title="线程私有型内存"></a>线程私有型内存</h3><p><strong>程序寄存器（PC Register）、Java栈（Stack）、本地方法栈（Native Stack）</strong></p>
<h3 id="线程共享型内存"><a href="#线程共享型内存" class="headerlink" title="线程共享型内存"></a>线程共享型内存</h3><p><strong>Java堆(Heap)、本地方法区(Method Area)</strong></p>
<h2 id="二、程序计数器-Program-Counter-Register"><a href="#二、程序计数器-Program-Counter-Register" class="headerlink" title="二、程序计数器 - Program Counter Register"></a>二、程序计数器 - Program Counter Register</h2><p><strong>程序计数器（Program Counter Register）是一块较小的内存空间</strong>，<code>它的作用可以看做是当前线程所执行的字节码的行号指示器</code>。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，<code>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器</code>，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为<code>“线程私有”</code>的内存。</p>
<p>如果线程正在执行的是一个Java方法，这个<code>计数器记录的是正在执行的虚拟机字节码指令的地址</code>；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p>
<p>此内存区域是<code>唯一</code>一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p>
<h2 id="三、Java栈-Java-Stack"><a href="#三、Java栈-Java-Stack" class="headerlink" title="三、Java栈 - Java Stack"></a>三、Java栈 - Java Stack</h2><p><strong>Java栈 - Java Stack</strong>  Java虚拟机栈（Java Virtual Machine Stacks）也是<code>线程私有</code>的，它的<code>生命周期与线程相同</code>。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个<code>栈帧（Stack Frame）</code>用于存储<code>局部变量表、操作栈、动态链接、方法出口</code>等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常状况：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；</li>
<li>如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<h3 id="栈帧-Stack-Frame"><a href="#栈帧-Stack-Frame" class="headerlink" title="栈帧(Stack Frame)"></a>栈帧(Stack Frame)</h3><h4 id="局部变量表（Local-Variable-Table）"><a href="#局部变量表（Local-Variable-Table）" class="headerlink" title="局部变量表（Local Variable Table）"></a>局部变量表<strong>（Local Variable Table）</strong></h4><p><code>局部变量表是一组变量值存储空间</code>，用于存放<code>方法参数</code>和<code>方法内部定义的局部变量</code>。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。局部变量表的容量以<code>变量槽（Slot）</code>为最小单位，每个变量槽都可以存储 32 位长度的内存空间.</p>
<p><strong>可存放数据类型</strong></p>
<p><code>基本数据类型（boolean、byte、char、short、int、float、long、double）</code></p>
<p>byte、short、char在存储之前转换为int，boolean在存储前转换为int，0标识false，1 标识true</p>
<p><code>对象引用（reference类型）</code></p>
<p>虚拟机规范没有明确说明它的长度，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置</p>
<p><code>returnAddress类型</code></p>
<p>指向了一条字节码指令的地址</p>
<p><strong>编译期确定占用内存空间大小</strong></p>
<p>其中<strong>64位长度的long和double类型的数据会占用2个局部变量空间（Slot）</strong>，其余的数据类型和 returnAddress（返回地址）只占用1个变量槽。当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p><strong>索引访问</strong></p>
<p>JVM会为局部变量表的每个Slot分配一个访问索引，通过这个索引可以访问到局部变量表中的局部变量值</p>
<p>占用两个Slot的变量也就是double和long，只需要使用前一个索引即可</p>
<p><strong>当前对象引用this</strong></p>
<p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存在局部变量表<code>第0位索引</code>的Slot处，非静态方法，都会创建this的一个参数，index为0，其余的参数是按照顺序排放的，static 方法被不可以使用this，是因为static方法中没有放this的index</p>
<p><strong>必须进行显式赋值</strong></p>
<p><code>系统不会为局部变量赋予初始值</code>（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。 局部变量：在使用前，必须进行显示赋值，否则编译不通过</p>
<h4 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈<strong>（Operand Stack）</strong></h4><p>Java虚拟机的解释执行引擎被称为”基于栈的执行引擎”，其中所指的栈就是指－操作数栈。</p>
<p>操作数栈 和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是<code>通过标准的栈操作——压栈和出栈—来访问的</code>。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。</p>
<p>虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。</p>
<p>虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中，看看下面的示例，它演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">iload_0    <span class="comment">// push the int in local variable 0 onto the stack</span></span><br><span class="line">iload_1    <span class="comment">//push the int in local variable 1 onto the stack</span></span><br><span class="line">iadd       <span class="comment">// pop two ints, add them, push result</span></span><br><span class="line">istore_2   <span class="comment">// pop int, store into local variable 2</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>在这个字节码序列里，前两个指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中，其后iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈。第四条指令istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。下图详细表述了这个过程中局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示。</p>
<p>如下图：</p>
<p><img src="https://i.loli.net/2020/06/04/vO534kpNEsdHlWG.png" alt="操作数栈.png"></p>
<h4 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接(Dynamic Linking)"></a>动态链接(Dynamic Linking)</h4><p>动态链接 : <code>虚拟机运行的时候,运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用</code>。持有这些引用是为了支持<strong>方法调用</strong>过程中的动态链接(Dynamic Linking)</p>
<p>如果A方法的栈帧的想调用B方法的栈帧，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。</p>
<ul>
<li>如果符号引用是在类加载阶段或者第一次使用的时候转化为直接引用，那么这种转换成为<strong>静态解析</strong>。</li>
<li>如果是在运行期间转换为直接引用，那么这种转换就成为<strong>动态连接</strong>。</li>
</ul>
<p><em>参考：</em></p>
<p><strong>方法调用</strong></p>
<p>方法调用并不等同于方法执行,方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法),暂时还不涉及方法内部的具体运行过程。</p>
<p>Class文件的编译过程中不包含传统编译中的连接步骤,一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(相当于之前说的直接引用)。</p>
<p>这个特性给Java带来了更强大的动态扩展能力,但也使得Java方法调用过程变得相对复杂起来,需要在类加载期间,甚至到运行期间才能确定目标方法的直接引用。</p>
<p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用,在类加载的解析阶段,会将其中的一部分符号引用转化为直接引用,这种解析能成立的前提是:方法在程序真正运行之前就有一个可确定的调用版本,并且这个方法的调用版本在运行期是不可改变的。换句话说,调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析(Resolution)。</p>
<p>在Java语言中符合“编译期可知,运行期不可变”这个要求的方法,主要包括静态方法和私有方法两大类,前者与类型直接关联,后者在外部不可被访问,这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本,因此它们都适合在类加载阶段进行解析。</p>
<p>与之相对应的是,在Java虚拟机里面提供了5条方法调用字节码指令,分别如下：</p>
<ul>
<li>invokestatic:调用静态方法</li>
<li>invokespecial:调用实例构造器方法、私有方法和父类方法。</li>
<li>invokevirtual:调用所有的虚方法。还有final修饰的方法。</li>
<li>invokeinterface:调用接口方法,会在运行时再确定一个实现此接口的对象。</li>
<li>invokedynamic:先在运行时动态解析出调用点限定符所引用的方法,然后再执行该方法,在此之前的4条调用指令,分派逻辑是固化在Java虚拟机内部的,而- - invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<p>只要能被invokestatic和invokespecial指令调用的方法,都可以在解析阶段中确定唯一的调用版本,符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类。</p>
<h4 id="方法返回-Invocation-Completion"><a href="#方法返回-Invocation-Completion" class="headerlink" title="方法返回(Invocation Completion)"></a>方法返回(Invocation Completion)</h4><p>方法的返回分为两种情况：</p>
<ul>
<li>一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者。</li>
<li>一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置。</span><br></pre></td></tr></table></figure>
<ul>
<li>如果方法是正常退出的，则<code>调用者的PC计数器的值就可以作为返回地址</code>；</li>
<li>如果是因为异常退出的，则是<code>需要通过异常处理表来确定</code>。</li>
</ul>
<p>方法的的一次调用就对应着栈帧在虚拟机栈中的一次入栈出栈操作，因此方法退出时可能做的事情包括：恢复上层方法的局部变量表以及操作数栈，如果有返回值的话，就把返回值压入到调用者栈帧的操作数栈中，还会把PC计数器的值调整为方法调用入口的下一条指令。</p>
<h2 id="四、本地方法栈-Native-Method-Stack"><a href="#四、本地方法栈-Native-Method-Stack" class="headerlink" title="四、本地方法栈 - Native Method Stack"></a>四、本地方法栈 - Native Method Stack</h2><p>本地方法栈（Native MethodStacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而<code>本地方法栈则是为虚拟机使用到的Native 方法服务</code>。本地方法栈也是<figure class="highlight plain"><figcaption><span>HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">与虚拟机栈一样，本地方法栈区域也会抛出`StackOverflowError`和`OutOfMemoryError`异常。</span><br><span class="line"></span><br><span class="line">## 五、方法区 - Method Area</span><br><span class="line"></span><br><span class="line">方法区用来存储类型的元数据信息，一个.class文件是类被java虚拟机使用之前的表现形式，一旦这个类要被使用，`java虚拟机就会对其进行装载、连接（验证、准备、解析）和初始化`，而装载后的结果就是由.class文件转变为方法区中的一段特定的数据结构。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 方法区的特点</span><br><span class="line"></span><br><span class="line">- `方法区是线程安全的`，由于所有的线程都共享方法区，所以方法区里的数据访问必须被设计成线程安全的。</span><br><span class="line">- `方法区的大小不必是固定的`，JVM可根据应用需要动态调整。</span><br><span class="line">- `方法区也可被垃圾收集`，当某个类不在被使用(不可触及)时，JVM将卸载这个类，进行垃圾收集。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> `当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。`</span><br><span class="line"></span><br><span class="line">### 方法区内存大小设置</span><br><span class="line"></span><br><span class="line">###### jdk6，jdk7 永久代</span><br><span class="line"></span><br><span class="line">```undefined</span><br><span class="line">-XX:PermSize=10M 初始化大小为10M。</span><br><span class="line">-XX:MaxPermSize=10M 最大内存为10M。</span><br></pre></td></tr></table></figure></p>
<h6 id="jdk8-元数据区"><a href="#jdk8-元数据区" class="headerlink" title="jdk8 元数据区"></a>jdk8 元数据区</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize=10M</span><br><span class="line">-XX:MaxMetaspaceSize=10M</span><br></pre></td></tr></table></figure>
<p>需要注意一点：<br>jdk8中永久代被移除了，取而代之的是元数据区</p>
<p>元空间（Metaspace）：元空间是方法区的在 HotSpot JVM 中的实现，方法区主要用于存储类信息、常量池、方法数据、方法代码、符号引用等。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p>
<p>元数据区发生溢出，虚拟机一样抛出异常：<code>java.lang.OutOfMemoryError Metaspace</code></p>
<h3 id="类信息"><a href="#类信息" class="headerlink" title="类信息"></a>类信息</h3><table>
<thead>
<tr>
<th>方法区</th>
<th>详细信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型信息</td>
<td>1. 类型的全限定名 2. 超类的全限定名 3. 直接超接口的全限定名 4. 类型标志（该类是类类型还是接口类型） 5.  类的访问描述符（public、private、default、abstract、final、static）</td>
</tr>
<tr>
<td>类型的常量池</td>
<td>存放该类型所用到的常量的有序集合，包括直接常量（如字符串、整数、浮点数的常量）和对其他类型、字段、方法的符号引用。常量池中每一个保存的常量都有一个索引，就像数组中的字段一样。因为常量池中保存中所有类型使用到的类型、字段、方法的符号引用，所以它也是动态连接（栈中对应的方法指向这个引用）的主要对象（在动态链接中起到核心作用）。</td>
</tr>
<tr>
<td>字段信息</td>
<td>1. 字段修饰符（public、protect、private、default） 2. 字段的类型 3. 字段名称</td>
</tr>
<tr>
<td>方法信息</td>
<td>1. 方法名 2.方法的返回类型（包括void）3. 方法参数的类型、数目以及顺序 4. 方法修饰符（public、private、protected、static、final、synchronized、native、abstract） 5. 针对非本地方法，还有些附加方法信息需要存储在方法区中（局部变量表大小和操作数栈大小、方法体字节码、异常表）</td>
</tr>
<tr>
<td>类变量（静态变量）</td>
<td>指该类所有对象共享的变量，即使没有创建该对象实例，也可以访问的类变量。它们与类进行绑定</td>
</tr>
<tr>
<td>指向类加载器的引用</td>
<td>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。JVM 在动态链接的时候需要这个信息。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。这对 JVM 区分名字空间的方式是至关重要的。</td>
</tr>
<tr>
<td>指向 Class 实例的引用</td>
<td>JVM 为每个加载的类和接口都创建一个 <code>java.lang.Class</code> 实例（JDK6 存储在方法区，JDK6 之后存储在 Java 堆），这个对象存储了所有这个字节码内存块的相关信息，如平时使用的 <code>this.getClass().getName()</code> <code>this.getClass().getDeclaredMethods()</code> <code>this.getClass().getDeclaredFields()</code>，可以获取类的各种信息，都是通过这个 Class 引用获取。</td>
</tr>
<tr>
<td>方法表</td>
<td>为了提高访问效率，必须仔细的设计存储在方法区中的数据信息结构。除了以上讨论的结构，JVM 的实现者还可以添加一些其他的数据结构，如方法表。JVM 对每个加载的非虚拟类的类型信息中都添加了一个方法表，方法表是一组对类实例方法的直接引用(包括从父类继承的方法)。JVM 可以通过方法表快速激活实例方法。</td>
</tr>
</tbody>
</table>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h4 id="Class文件中的常量池"><a href="#Class文件中的常量池" class="headerlink" title="Class文件中的常量池"></a>Class文件中的常量池</h4><p>在Class文件结构中，最头的4个字节用于存储Megic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。</p>
<p>常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)</p>
<p><img src="https://i.loli.net/2020/06/05/kq9ActHz1QOeU3K.png" alt="常量池.jpg"></p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>CLass文件中的常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p>
<h4 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h4><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p>
<p>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p>
<ul>
<li>节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li>
<li>节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li>
</ul>
<h2 id="六、Java-堆-Heap"><a href="#六、Java-堆-Heap" class="headerlink" title="六、Java 堆 (Heap)"></a>六、Java 堆 (Heap)</h2><p>Java堆（Java Heap）是被所有<code>线程共享</code>的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li>新生代（Young Generation）</li>
<li>老年代（Old Generation）</li>
</ul>
<p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</span><br></pre></td></tr></table></figure>
<p>-Xms  堆内存初始值</p>
<p>-Xmx  堆内存最大值</p>
<p>默认的，<code>新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2</code>( 该值可以通过参数 <code>–XX:NewRatio</code>来指定 )，<br> 即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/box/2aa0380c/">JVM——CMS、G1收集器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/日志/">日志</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><h1 id="JVM——CMS、G1收集器"><a href="#JVM——CMS、G1收集器" class="headerlink" title="JVM——CMS、G1收集器"></a>JVM——CMS、G1收集器</h1><h2 id="CMS回收垃圾的4个阶段"><a href="#CMS回收垃圾的4个阶段" class="headerlink" title="CMS回收垃圾的4个阶段"></a>CMS回收垃圾的4个阶段</h2><ol>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清理</li>
</ol>
<p><img src="https://i.loli.net/2020/05/25/RTXYaGhwOQIeyjt.jpg" alt="cms.jpeg"></p>
<p>初始标记阶段：（CMS initial mark）标记GC Roots能直接关联的对象，时间短用户线程停顿，也就是 Stop the World 状态</p>
<p>并发标记阶段：（CMS concurrent mark）GC Roots直接关联对象向下遍历整个对象图，时间长不需要用户线程停顿，这个阶段最耗费时, 但这个阶段是和系统并发运行的，所以不会对系统运行造成影响</p>
<p>重新标记阶段：（CMS remark）由于第二阶段是并发执行的，一边标记垃圾对象，一边创建新对象，老对象会变成垃圾对象。 所以第三阶段也会进入 Stop the World 状态，并且重新标记，标记的是第二阶段中变动过的少数对象，所以运行速度很快</p>
<p>并发清理阶段：（CMS concurrent sweep） 清理删除掉标记阶段判断已经死亡的对象, 这个阶段也是会耗费很多时间，但由于是并发运行的，所以对系统不会造成很大的影响</p>
<h2 id="CMS优缺点"><a href="#CMS优缺点" class="headerlink" title="CMS优缺点"></a><strong>CMS优缺点</strong></h2><p>CMS采用 标记-清理 的算法，标记出垃圾对象，清除垃圾对象。算法是基于老年代执行的，因为新生代产生无法接受该算法产生的碎片垃圾。新生代配合ParNew收集器使用</p>
<p><strong>优点</strong>：并发收集，低停顿</p>
<p><strong>不足</strong>：</p>
<ul>
<li>无法处理浮动垃圾，并发收集会造成内存碎片过多</li>
<li>由于并发标记和并发清理阶段都是并发执行，所以会额外消耗CPU资源</li>
</ul>
<h2 id="CMS相关JVM参数"><a href="#CMS相关JVM参数" class="headerlink" title="CMS相关JVM参数"></a>CMS相关JVM参数</h2><p>-XmxM4096M：设置JVM最大可用内存为4096M。<br>-Xms4096M ：设置JVM初始内存为4096M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p>
<p>-Xmn1536M  -Xss256K -XX:+DisableExplicitGC -XX:SurvivorRatio=2 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled -XX:LargePageSizeInBytes=128M -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=80 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:/export/Logs/gc.log -XX:HeapDumpPath=/export/Logs/gc.hprof -Dfastjson.parser.autoTypeSupport=true</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseSerialGC</span>：在新生代和老年代使用串行收集器</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:SurvivorRatio</span>：设置<span class="selector-tag">eden</span>区大小和<span class="selector-tag">survivior</span>区大小的比例</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:NewRatio</span>:新生代和老年代的比</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseParNewGC</span>：在新生代使用并行收集器</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseParallelGC</span> ：新生代使用并行回收收集器</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseParallelOldGC</span>：老年代使用并行回收收集器</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:ParallelGCThreads</span>：设置用于垃圾回收的线程数</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseConcMarkSweepGC</span>：新生代使用并行收集器，老年代使用<span class="selector-tag">CMS</span>+串行收集器</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:ParallelCMSThreads</span>：设定<span class="selector-tag">CMS</span>的线程数量</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:CMSInitiatingOccupancyFraction</span>：设置<span class="selector-tag">CMS</span>收集器在老年代空间被使用多少后触发</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseCMSCompactAtFullCollection</span>：设置<span class="selector-tag">CMS</span>收集器在完成垃圾收集后是否要进行一次内存碎片的整理</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:CMSFullGCsBeforeCompaction</span>：设定进行多少次<span class="selector-tag">CMS</span>垃圾回收后，进行一次内存压缩</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+CMSClassUnloadingEnabled</span>：允许对类元数据进行回收</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:CMSInitiatingPermOccupancyFraction</span>：当永久区占用率达到这一百分比时，启动<span class="selector-tag">CMS</span>回收</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:UseCMSInitiatingOccupancyOnly</span>：表示只在到达阀值的时候，才进行<span class="selector-tag">CMS</span>回收</span><br></pre></td></tr></table></figure>
<h2 id="G1回收垃圾的4个阶段"><a href="#G1回收垃圾的4个阶段" class="headerlink" title="G1回收垃圾的4个阶段"></a>G1回收垃圾的4个阶段</h2><ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p><img src="https://i.loli.net/2020/05/25/9bkXqynZ6g7waBN.jpg" alt="G1.jpeg"></p>
<p><strong>初始标记（Initail Marking）：</strong>标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</p>
<p><strong>并发标记（Concurrent Marking）：</strong>从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</p>
<p><strong>最终标记（Final Marking）：</strong>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录（好比一个阿姨一边清理垃圾，另一个人一边扔垃圾）虚拟机会将这段时间的变化记录在Remembered Set Logs 中。最终标记阶段需要把Remenbered Set Logs的数据合并到Remenbered Set中。这个阶段需要线程停顿，但可以并发执行</p>
<p><strong>筛选回收（Live Data Counting and Evacuation）：</strong>首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p>
<h2 id="G1回收器的特点"><a href="#G1回收器的特点" class="headerlink" title="G1回收器的特点"></a>G1回收器的特点</h2><h5 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h5><p>G1把Java内存拆分成多等份，多个域（Region），逻辑上存在新生代和老年代的概念，但是没有严格区分</p>
<p>。Region最多分为2048个</p>
<p><img src="https://i.loli.net/2020/05/25/cxWRfGsmLdJhIFe.png" alt="G1-JVM.png"></p>
<h5 id="可预测的停顿"><a href="#可预测的停顿" class="headerlink" title="可预测的停顿"></a>可预测的停顿</h5><ul>
<li><p>G1收集器之所以建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p>
</li>
<li><p>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。</p>
</li>
<li><p>这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
</li>
<li><p>G1把内存“化整为零”的思路。把Java堆分为多个Region后，垃圾收集是否就真的能以Region为单位进行了？</p>
</li>
<li><p>Region不可能是孤立的。一个对象分配在某个Region中，它并非只能被本Region中的其他对象引用，而是可以与整个Java堆任意的对象发生引用关系。</p>
</li>
<li><p>那在做可达性判定确定对象是否存活的时候，岂不是还得扫描整个Java堆才能保证准确性？</p>
</li>
<li><p>在以前的分代收集中，新生代的规模一般都比老年代要小许多，新生代的收集也比老年代要频繁许多，那回收新生代中的对象时也面临相同的问题，如果回收新生代时也不得不同时扫描老年代的话，那么Minor GC的效率可能下降不少。</p>
</li>
<li><p>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。</p>
</li>
<li><p>G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。</p>
</li>
<li><p>当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会遗漏。</p>
</li>
</ul>
<h5 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h5><ul>
<li>与CMS的“标记——清理”算法不同，G1从整体来看是基于“标记——整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。</li>
<li>这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li>
</ul>
<h3 id="大对象的处理"><a href="#大对象的处理" class="headerlink" title="大对象的处理"></a>大对象的处理</h3><p>除了上面优点之外，还有一个优点，那就是对大对象的处理。在CMS内存中，如果一个对象过大，进入S1、S2区域的时候大于改分配的区域，对象会直接进入老年代。G1处理大对象时会判断对象是否大于一个Region大小的50%，如果大于50%就会横跨多个Region进行存放</p>
<h2 id="什么情况下应该考虑使用G1"><a href="#什么情况下应该考虑使用G1" class="headerlink" title="什么情况下应该考虑使用G1"></a>什么情况下应该考虑使用G1</h2><ul>
<li><p>实时数据占用超过一半的堆空间</p>
</li>
<li><p>对象分配或者晋升的速度变化大</p>
</li>
<li><p>希望消除长时间的GC停顿（超过0.5-1秒）</p>
<p>个人实践：当使用CMS，并发调用量大时，Young GC频繁，可以考虑使用G1，可以有效降低Young GC频率</p>
</li>
</ul>
<h3 id="G1设置参数"><a href="#G1设置参数" class="headerlink" title="G1设置参数"></a>G1设置参数</h3><p>控制G1回收垃圾的时间</p>
<p>-XX:MaxGCPauseMillis=200 （默认200ms）</p>
<p>G1收集器是一个自适应的垃圾收集器，它的默认值无需修改就可以高效的工作，下表列出了一下重要的参数和其默认值：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数及其默认值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-XX:G1HeapRegionSize = n</td>
<td style="text-align:center">设置<code>region</code>的大小，该值为2的幂，范围为1MB到32 MB，目标是根据最小Java堆大小，将堆分成大约2048个<code>region</code>。</td>
</tr>
<tr>
<td style="text-align:center">-XX:MaxGCPauseMillis = 200</td>
<td style="text-align:center">设置最大停顿时间，默认值为200毫秒。</td>
</tr>
<tr>
<td style="text-align:center">-XX:G1NewSizePercent = 5</td>
<td style="text-align:center">设置年轻代占整个堆的最小百分比，默认值是5，这是个<strong>实验参数</strong>，如果设置该值，将覆盖默认参数 -XX:DefaultMinNewGenPercent。（JVM build &gt; 23）</td>
</tr>
<tr>
<td style="text-align:center">-XX:G1MaxNewSizePercent = 60</td>
<td style="text-align:center">设置年轻代占整个堆的最大百分比，默认值是60，这是个<strong>实验参数</strong>，如果设置该值，将覆盖默认参数 -XX:DefaultMaxNewGenPercent。（JVM build &gt; 23）</td>
</tr>
<tr>
<td style="text-align:center">-XX:ParallelGCThreads = n</td>
<td style="text-align:center">设置STW的垃圾收集线程数，当逻辑处理器数量小于8时，n的值与逻辑处理器数量相同；如果逻辑处理器数量大于8个，则n的值大约为逻辑处理器数量的5/8，大多数情况下是这样，除了较大的SPARC系统，其中n的值约为逻辑处理器的5/16。</td>
</tr>
<tr>
<td style="text-align:center">-XX:ConcGCThreads = n</td>
<td style="text-align:center">设置并行标记线程的数量，设置n大约为ParallelGCThreads参数值的1/4。</td>
</tr>
<tr>
<td style="text-align:center">-XX:InitiatingHeapOccupancyPercent = 45</td>
<td style="text-align:center">设置触发标记周期的Java堆占用阈值，默认值为45。</td>
</tr>
<tr>
<td style="text-align:center">-XX:G1MixedGCLiveThresholdPercent = 85</td>
<td style="text-align:center">设置要包含在混合垃圾收集周期中的<code>old region</code>的占用阈值，默认值为85。这是个<strong>实验参数</strong>，如果设置该值，将覆盖默认参数 -XX:G1OldCSetRegionLiveThresholdPercent。（JVM build &gt; 23）</td>
</tr>
<tr>
<td style="text-align:center">-XX:G1HeapWastePercent=5</td>
<td style="text-align:center">设置浪费的堆内存百分比，当可回收百分比小于浪费百分比时，JVM就不会启动混合垃圾收。（就是设置垃圾对象占用内存百分比的最大值）。（JVM build &gt; 23）</td>
</tr>
<tr>
<td style="text-align:center">-XX:G1MixedGCCountTarget = 8</td>
<td style="text-align:center">设置在标记周期完成之后混合收集的数量，以维持<code>old region</code>（也就是老年代）中，最多有G1MixedGCLiveThresholdPercent的存活对象。默认值为8，混合收集的数量将维持在这个值之内。（JVM build &gt; 23）</td>
</tr>
<tr>
<td style="text-align:center">-XX:G1OldCSetRegionThresholdPercent = 10</td>
<td style="text-align:center">设置在一次混合收集中被收集的<code>old region</code>数量的上线，默认值是整个堆的10%。（JVM build &gt; 23）</td>
</tr>
<tr>
<td style="text-align:center">-XX:G1ReservePercent = 10</td>
<td style="text-align:center">设置预留空闲内存百分比，以降低内存溢出的风险。默认值为10％。增加或减少百分比时，请确保将总Java堆调整相同的量。（JVM build &gt; 23）</td>
</tr>
</tbody>
</table>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/box/d107926b/">茶——人在草木间</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/杂文/">杂文</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/茶/">茶</a></span><div class="content"><h1 id="茶——人在草木间"><a href="#茶——人在草木间" class="headerlink" title="茶——人在草木间"></a>茶——人在草木间</h1><h2 id="历史起源"><a href="#历史起源" class="headerlink" title="历史起源"></a>历史起源</h2><p>茶之为饮，发乎于神农氏</p>
<p>唐以前不普及，主要是王公贵族饮茶</p>
<p>唐朝发展壮大，陆羽《茶经》</p>
<p>宋茶顶峰时期，斗茶成风</p>
<p>明朝由茶饼到散茶，烹煮到清饮</p>
<h2 id="六大茶类"><a href="#六大茶类" class="headerlink" title="六大茶类"></a>六大茶类</h2><p><img src="https://i.loli.net/2019/12/03/b5l8XGTICz7RNFw.jpg" alt></p>
<p>绿茶：不发酵</p>
<p>白茶：微发酵</p>
<p>黄茶：轻发酵</p>
<p>乌龙茶（青茶）：半发酵</p>
<p>红茶：全发酵</p>
<p>黑茶：后发酵</p>
<h2 id="中国十大名茶"><a href="#中国十大名茶" class="headerlink" title="中国十大名茶"></a>中国十大名茶</h2><p>西湖龙井：“色绿、香郁、味甘、形美”，“狮（峰）、龙（井）、云（栖）、虎（跑）、梅（家坞）”，外观扁平光润、挺直尖削，栗香、豆香</p>
<p>洞庭碧螺春：太湖洞庭山，“条索纤细、卷曲成螺，满身披毫”，茶果间作，花果香，“吓煞人香”</p>
<p>黄山毛峰：“绿中泛黄，色如象牙，鱼叶金黄”</p>
<p>六安瓜片：形似瓜子，叶面向内翻卷，着白霜色，无芽无梗</p>
<p>信阳毛尖：“细、圆、光、直、多白毫、香高、味浓、汤色绿”</p>
<p>君山银针：茶芽金黄，白毫显露，外形象一根根银针，“白鹤茶”，“黄翎毛”，“金镶玉”</p>
<p>都匀毛尖：“干茶绿中带黄，汤色绿中透黄，叶底绿中显黄”的“三绿三黄”</p>
<p>祁门红茶：“祁红特绝群芳最，清誉高香不二门”，“群芳最”、“红茶皇后”  印度大吉岭茶——“茶中香槟”  ，锡兰红茶乌瓦茶——“献给世界的礼物”</p>
<p>武夷岩茶：岩韵，岩骨花香，分为肉桂（灌木）、水仙（小乔木），奇种（五大名枞：大红袍、铁罗汉、白鸡冠、水金龟、半天腰）</p>
<p>安溪铁观音：茶叶紧结，叶身沉重，圆整呈蜻蜓头，青蛙腿，“观音韵”</p>
<p><strong>发酵</strong>指人们借助微生物在有氧或无氧条件下的生命活动来制备微生物菌体本身、或者直接代谢产物或次级代谢产物的过程</p>
<p><strong>茶叶的“发酵”</strong>其实是在细胞壁破损后，存在于细胞壁中的氧化酶类促进儿茶素类进行的一系列的氧化过程。这一过程更像是一系列的酶促反应</p>
<p><strong>茶叶的后发酵才是真正意义上的发酵，由微生物参与起作用</strong>，这个过程与发面团、做酸奶、酿酒的发酵是一回事。</p>
<p><strong>后发酵</strong>，说的就是在杀青后进行发酵，这是制作黑茶的必要工序，在制作黑茶的时候，杀青、揉捻之后，人们就把茶叶的半成品堆放在一起，利用湿热促进微生物发酵，这个过程就叫<strong>“渥堆”</strong>。</p>
<p>生普：杀青不杀透，部分酶的活性被保留了下来，长期的保存中缓慢发酵，越陈越香，<strong>酶促发酵</strong></p>
<p>熟普：<strong>微生物后发酵</strong></p>
<h2 id="茶的化学成分"><a href="#茶的化学成分" class="headerlink" title="茶的化学成分"></a>茶的化学成分</h2><h3 id="茶多酚（涩）"><a href="#茶多酚（涩）" class="headerlink" title="茶多酚（涩）"></a><strong>茶多酚</strong>（涩）</h3><p>茶多酚是茶叶中多酚类物质的总称，为白色不定形粉末，易溶于水，其中含有30 种以上的酚类物质。茶多酚按主要化学成分分为儿茶素类、黄酮类、花青素类、酚酸类四大类物质。在这四类物质中，儿茶素含量最高，占茶多酚总量的60%-80%，其次是黄酮类，其他酚类物质含量比较少</p>
<h3 id="生物碱（苦）"><a href="#生物碱（苦）" class="headerlink" title="生物碱（苦）"></a><strong>生物碱</strong>（苦）</h3><p>主要有咖啡碱、可可碱、茶叶碱、腺嘌呤、鸟嘌呤等。其中含量最多的是咖啡碱，占茶叶干重的2%~4%，其次是可可碱，约占总量的0.05%，再其次是茶叶碱，约占0.002%。</p>
<h3 id="糖类物质（甜）"><a href="#糖类物质（甜）" class="headerlink" title="糖类物质（甜）"></a><strong>糖类物质</strong>（甜）</h3><p>茶叶中的糖类物质包括单糖、寡糖、多糖及其少量其他糖类。其含量占干物质总量的20%～25%。</p>
<p>单糖和双糖又称可溶性糖，易溶于水，含量为0.8%～4%，是组成茶叶滋味的物质之一。茶叶中的多糖包括淀粉、纤维素、半纤维素和木质素等物质，含量占茶叶干物质总量的20%以上，多糖不溶于水，是衡量茶叶老嫩度的重要成分。茶叶嫩度低，多糖含量高；嫩度高，多糖含量低。</p>
<h3 id="氨基酸（鲜）"><a href="#氨基酸（鲜）" class="headerlink" title="氨基酸（鲜）"></a><strong>氨基酸</strong>（鲜）</h3><p>氨基酸是组成蛋白质的基本物质，含量占干物质总量的1%～4%。茶叶中的氨基酸已发现有茶氨酸、谷氨酸、天门冬氨酸等26种,鲜爽的口感。</p>
<h3 id="果胶（稠）"><a href="#果胶（稠）" class="headerlink" title="果胶（稠）"></a><strong>果胶</strong>（稠）</h3><p>茶叶中的果胶等物质是糖的代谢产物，含量占干物质总量的4%左右。果胶的存在有利于茶叶加工过程中手工揉捻成形，且跟茶汤粘稠度等有关。水溶性果胶是形成茶汤厚度和外形光泽度的主要成分之一。</p>
<h3 id="色素"><a href="#色素" class="headerlink" title="色素"></a><strong>色素</strong></h3><p>茶叶中的色素包括脂溶性色素和水溶性色素两部分，含量仅占茶叶干物质总量的1%左右。脂溶性色素不溶于水，有叶绿素、叶黄素、胡萝卜素等。水溶性色素有黄酮类物质、花青素及茶多酚氧化产物茶黄素、茶红素和茶褐素等。</p>
<p>随着氧化程度增高，茶黄素—&gt;茶红素—&gt;茶褐素</p>
<p><strong>茶黄素</strong>：明亮，鲜爽，易氧化，“软黄金”</p>
<p><strong>茶红素</strong>：刺激性较弱，醇和</p>
<p><strong>茶褐素</strong>：淡薄</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>水分、芳香物质、无机化合物、蛋白质等等</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/box/ccf7cbc/">Git多仓库配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/日志/">日志</a></span><div class="content"><h1 id="Git多仓库配置"><a href="#Git多仓库配置" class="headerlink" title="Git多仓库配置"></a>Git多仓库配置</h1><p>原文见：<a href="https://www.cnblogs.com/bwar/p/9297343.html" target="_blank" rel="noopener">https://www.cnblogs.com/bwar/p/9297343.html</a></p>
<h3 id="远程仓库的git-config"><a href="#远程仓库的git-config" class="headerlink" title="远程仓库的git config"></a>远程仓库的git config</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[core]</span></span><br><span class="line">        <span class="string">repositoryformatversion</span> <span class="string">=</span> <span class="number">0</span></span><br><span class="line">        <span class="string">filemode</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="string">bare</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="string">logallrefupdates</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="string">symlinks</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="string">ignorecase</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="string">[remote</span> <span class="string">"origin"</span><span class="string">]</span></span><br><span class="line">        <span class="string">url</span> <span class="string">=</span> <span class="attr">https://github.com/wq/project.git</span></span><br><span class="line">        <span class="string">fetch</span> <span class="string">=</span> <span class="string">+refs/heads/*:refs/remotes/origin/*</span></span><br><span class="line"><span class="string">[branch</span> <span class="string">"master"</span><span class="string">]</span></span><br><span class="line">        <span class="string">remote</span> <span class="string">=</span> <span class="string">origin</span></span><br><span class="line">        <span class="string">merge</span> <span class="string">=</span> <span class="string">refs/heads/master</span></span><br></pre></td></tr></table></figure>
<h3 id="用git命令行添加多个远程仓库"><a href="#用git命令行添加多个远程仓库" class="headerlink" title="用git命令行添加多个远程仓库"></a>用git命令行添加多个远程仓库</h3><p>添加一个名为“mirror”的远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add mirror https://git.coding.net/wq/project.git</span><br></pre></td></tr></table></figure>
<p>执行完这条命令后.git/config文件内容变成了：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[core]</span></span><br><span class="line">        <span class="string">repositoryformatversion</span> <span class="string">=</span> <span class="number">0</span></span><br><span class="line">        <span class="string">filemode</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="string">bare</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="string">logallrefupdates</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="string">symlinks</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="string">ignorecase</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="string">[remote</span> <span class="string">"origin"</span><span class="string">]</span></span><br><span class="line">        <span class="string">url</span> <span class="string">=</span> <span class="attr">https://github.com/wq/project.git</span></span><br><span class="line">        <span class="string">fetch</span> <span class="string">=</span> <span class="string">+refs/heads/*:refs/remotes/origin/*</span></span><br><span class="line"><span class="string">[branch</span> <span class="string">"master"</span><span class="string">]</span></span><br><span class="line">        <span class="string">remote</span> <span class="string">=</span> <span class="string">origin</span></span><br><span class="line">        <span class="string">merge</span> <span class="string">=</span> <span class="string">refs/heads/master</span></span><br><span class="line"><span class="string">[remote</span> <span class="string">"mirror"</span><span class="string">]</span></span><br><span class="line">        <span class="string">url</span> <span class="string">=</span> <span class="attr">https://git.coding.net/wq/project.git</span></span><br><span class="line">        <span class="string">fetch</span> <span class="string">=</span> <span class="string">+refs/heads/*:refs/remotes/mirror/*</span></span><br></pre></td></tr></table></figure>
<p>此时已经是一个本地仓库，两个远程仓库。使用下面的命令可以分别从两个远程仓库拉取和推送到两个远程仓库。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">pull</span> <span class="string">origin</span> <span class="string">master</span> </span><br><span class="line"><span class="string">git</span> <span class="string">pull</span> <span class="string">mirror</span> <span class="string">master</span></span><br><span class="line"><span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">master</span> </span><br><span class="line"><span class="string">git</span> <span class="string">push</span> <span class="string">mirror</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h3 id="一条命令同时更新多个远程仓库"><a href="#一条命令同时更新多个远程仓库" class="headerlink" title="一条命令同时更新多个远程仓库"></a>一条命令同时更新多个远程仓库</h3><p>直接在origin中添加一个url来实现一个本地仓库多个远程仓库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote set-url --add origin https://coding.com/wq/project.git</span><br></pre></td></tr></table></figure></div><a class="more" href="/box/ccf7cbc/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/box/2c3ea3f5/">Spark——Structured streaming + hive sink</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/日志/">日志</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/scala/">scala</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/spark/">spark</a></span><div class="content"><h1 id="Spark——Structured-streaming-hive-sink"><a href="#Spark——Structured-streaming-hive-sink" class="headerlink" title="Spark——Structured streaming + hive sink"></a>Spark——Structured streaming + hive sink</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>需求：Structured streaming消费kafka并将数据写入Hive表</p>
<p>spark 版本 2.3.1</p>
<p>scala 版本 2.11.8</p>
<p>spark从2.4版本以后，支持foreachBatch</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">streamingDF.writeStream.foreachBatch &#123; (batchDF: <span class="type">DataFrame</span>, batchId: <span class="type">Long</span>) =&gt;</span><br><span class="line">  <span class="comment">// Transform and write batchDF </span></span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure>
<p>所以本次需要自定义sink实现写Hive的操作</p>
<h2 id="Structured-streaming-消费kafka"><a href="#Structured-streaming-消费kafka" class="headerlink" title="Structured streaming 消费kafka"></a>Structured streaming 消费kafka</h2><h3 id="消费kafka数据，对json数据进行transform"><a href="#消费kafka数据，对json数据进行transform" class="headerlink" title="消费kafka数据，对json数据进行transform"></a>消费kafka数据，对json数据进行transform</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.<span class="type">Timestamp</span></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.&#123;<span class="type">JSON</span>, <span class="type">JSONObject</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.streaming.<span class="type">Trigger</span></span><br><span class="line"><span class="keyword">import</span> org.slf4j.<span class="type">LoggerFactory</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StructuredReceiver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">LOGGER</span> = <span class="type">LoggerFactory</span>.getLogger(<span class="type">StructuredReceiver</span>.getClass)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> suffix = <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> (args != <span class="literal">null</span> &amp;&amp; args.length &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      suffix = args(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> checkpointDirectory = <span class="string">"/user/checkpoint/StructuredReceiver"</span> + suffix</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"StructuredReceiver"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ss = <span class="type">SparkSession</span>.builder().enableHiveSupport().config(conf).getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> ss.implicits._</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lines = ss</span><br><span class="line">      .readStream</span><br><span class="line">      .format(<span class="string">"kafka"</span>)</span><br><span class="line">      .option(<span class="string">"kafka.bootstrap.servers"</span>, <span class="string">"host1:port1,host2:port2"</span>)</span><br><span class="line">      .option(<span class="string">"subscribe"</span>, <span class="string">"topic"</span>)</span><br><span class="line">      .load()</span><br><span class="line">      .selectExpr(<span class="string">"CAST(key AS STRING)"</span>, <span class="string">"CAST(value AS STRING)"</span>, <span class="string">"CAST(timestamp AS TIMESTAMP)"</span>)</span><br><span class="line">      .as[(<span class="type">String</span>, <span class="type">String</span>, <span class="type">Timestamp</span>)]</span><br><span class="line"></span><br><span class="line">	<span class="comment">//数据transform</span></span><br><span class="line">    <span class="keyword">val</span> resultDf = lines.map(record =&gt; &#123;</span><br><span class="line">      <span class="keyword">var</span> json: <span class="type">JSONObject</span> = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        json = <span class="type">JSON</span>.parseObject(record._2)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; &#123;</span><br><span class="line">          <span class="type">LOGGER</span>.warn(<span class="string">"parse josn erro"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (json == <span class="literal">null</span> || json.isEmpty) &#123;</span><br><span class="line">        (<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> appName = json.getString(<span class="string">"appName"</span>)</span><br><span class="line">        <span class="keyword">val</span> msg = json.getString(<span class="string">"msg"</span>)</span><br><span class="line">        (appName, msg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).filter(pair =&gt; pair._1 != <span class="literal">null</span> &amp;&amp; pair._1 != <span class="string">""</span> &amp;&amp; pair._2 != <span class="literal">null</span> &amp;&amp; pair._2 != <span class="string">""</span>).map(pair =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> appName = pair._1</span><br><span class="line">      <span class="keyword">val</span> msg = pair._2</span><br><span class="line">      <span class="keyword">val</span> values = msg.split(<span class="string">"\t"</span>)</span><br><span class="line">      (values(<span class="number">0</span>), values(<span class="number">1</span>).toLong, values(<span class="number">2</span>).toInt, values(<span class="number">3</span>))</span><br><span class="line">    &#125;).toDF()</span><br><span class="line"></span><br><span class="line">    resultDf.writeStream</span><br><span class="line">      .outputMode(<span class="string">"append"</span>)</span><br><span class="line">      .trigger(<span class="type">Trigger</span>.<span class="type">ProcessingTime</span>(<span class="string">"10 seconds"</span>))<span class="comment">//批次时间</span></span><br><span class="line">      .format(<span class="string">"com.warmqing.spark.HiveSinkProvider"</span>)<span class="comment">//自定义HiveSinkProvider</span></span><br><span class="line">      .option(<span class="string">"checkpointLocation"</span>, checkpointDirectory)</span><br><span class="line">      .start()</span><br><span class="line">      .awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a class="more" href="/box/2c3ea3f5/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/box/8be2bca3/">Elasticsearch 深分页问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/日志/">日志</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Elasticsearch/">Elasticsearch</a></span><div class="content"><h1 id="Elasticsearch-深分页问题"><a href="#Elasticsearch-深分页问题" class="headerlink" title="Elasticsearch 深分页问题"></a>Elasticsearch 深分页问题</h1><h1 id="——from-size、search-after、scroll"><a href="#——from-size、search-after、scroll" class="headerlink" title="——from+size、search after、scroll"></a>——from+size、search after、scroll</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>订单查询从mysql迁移至Es，分页查询订单有超过1w条的需求</p>
<h2 id="Es几种分页方式"><a href="#Es几种分页方式" class="headerlink" title="Es几种分页方式"></a>Es几种分页方式</h2><h3 id="from-size"><a href="#from-size" class="headerlink" title="from+size"></a>from+size</h3><p>1、coordinate node向index的其余的shards 发送同样的请求，请求查询from+size条记录</p>
<p>2、汇总<code>（shards * （from + size））</code>条记录到coordinate node</p>
<p>3、coordinate node排序记录，最终抽取出真正的 from 后的 size 条结果</p>
<p>索引非常大时（千万级或亿级），无法用这个方法做深度分页，有OOM的风险</p>
<p>Java API：6.3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SearchResponse response = client.prepareSearch(<span class="string">"index1"</span>, <span class="string">"index2"</span>)</span><br><span class="line">        .setSearchType(SearchType.DFS_QUERY_THEN_FETCH)</span><br><span class="line">        .setQuery(QueryBuilders.termQuery(<span class="string">"multi"</span>, <span class="string">"test"</span>))                 <span class="comment">// Query</span></span><br><span class="line">        .setPostFilter(QueryBuilders.rangeQuery(<span class="string">"age"</span>).from(<span class="number">12</span>).to(<span class="number">18</span>))     <span class="comment">// Filter</span></span><br><span class="line">        .setFrom(<span class="number">0</span>).setSize(<span class="number">60</span>).setExplain(<span class="keyword">true</span>)</span><br><span class="line">        .get();</span><br></pre></td></tr></table></figure>
<h2 id="search-after"><a href="#search-after" class="headerlink" title="search after"></a>search after</h2><p>1、search after需要指定排序</p>
<p>官方文档建议：</p>
<p>每个文档具有一个唯一值的字段应该用作排序。否则，具有相同排序值的文档的排序顺序将无法识别。建议的方法是使用每个文档唯一值字段<code>_id</code>排序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET twitter/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"size"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match"</span> : &#123;</span><br><span class="line">            <span class="string">"title"</span> : <span class="string">"elasticsearch"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"search_after"</span>: [<span class="number">1463538857</span>, <span class="string">"654323"</span>],</span><br><span class="line">    <span class="string">"sort"</span>: [</span><br><span class="line">        &#123;<span class="string">"date"</span>: <span class="string">"asc"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"_id"</span>: <span class="string">"desc"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当时使用文档的<code>_id</code>排序感觉很慢，后使用业务中的<code>id</code>字段</p>
<p>2、必须从第一页开始搜起（你可以随便指定一个坐标让它返回结果，只是你不知道会在全量结果的何处）</p>
<p>3、从第一页开始以后每次都带上<code>search_after</code> 排序值，从而为无状态实现一个状态，把每次固定的from + size偏移变成一个确定值，而查询则从这个偏移量开始获取size个doc，每个shard 获取size个，coordinate node最后汇总 shards*size 个。<strong>search after是一个常量查询延迟和开销</strong></p>
<p>Java API：6.3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SearchResponse response = client.prepareSearch(<span class="string">"index1"</span>, <span class="string">"index2"</span>)</span><br><span class="line">        .setSearchType(SearchType.DFS_QUERY_THEN_FETCH)</span><br><span class="line">        .setQuery(QueryBuilders.termQuery(<span class="string">"multi"</span>, <span class="string">"test"</span>))  <span class="comment">// Query</span></span><br><span class="line">		.searchAfter(sortValues)   <span class="comment">//sortValues</span></span><br><span class="line">        .setPostFilter(QueryBuilders.rangeQuery(<span class="string">"age"</span>).from(<span class="number">12</span>).to(<span class="number">18</span>))     <span class="comment">// Filter</span></span><br><span class="line">        .setFrom(<span class="number">0</span>).setSize(<span class="number">60</span>).setExplain(<span class="keyword">true</span>)</span><br><span class="line">        .get();</span><br></pre></td></tr></table></figure>
<p>使用search after方式，参数<code>from</code>必须设置为0（或-1）<br></p></div><a class="more" href="/box/8be2bca3/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/box/2b73e945/">Elasticsearch 基本概念</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/日志/">日志</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Elasticsearch/">Elasticsearch</a></span><div class="content"><h1 id="Elasticsearch-基本概念"><a href="#Elasticsearch-基本概念" class="headerlink" title="Elasticsearch 基本概念"></a>Elasticsearch 基本概念</h1><h3 id="索引-Index"><a href="#索引-Index" class="headerlink" title="索引(Index)"></a>索引(Index)</h3><p>ES将数据存储于一个或多个索引中，索引是具有类似特性的文档的集合。类比传统的关系型数据库领域来说，索引相当于SQL中的一个数据库，或者一个数据存储方案(schema)。索引由其名称(必须为全小写字符)进行标识，并通过引用此名称完成文档的创建、搜索、更新及删除操作。一个ES集群中可以按需创建任意数目的索引。<br></p></div><a class="more" href="/box/2b73e945/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/box/44b989a/">表驱动方法在java、scala中的实践</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/日志/">日志</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/scala/">scala</a></span><div class="content"><h1 id="表驱动方法在java、scala中的实践"><a href="#表驱动方法在java、scala中的实践" class="headerlink" title="表驱动方法在java、scala中的实践"></a>表驱动方法在java、scala中的实践</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表驱动法是一种编程模式（Scheme），从表里面查找信息而不使用逻辑语句（if 和case） 它的好处是消除代码里面到处出现的if、else、swith语句，让凌乱代码变得简明和清晰。</span><br><span class="line">对简单情况而言，表驱动方法可能仅仅使逻辑语句更容易和直白，但随着逻辑的越来越复杂，表驱动法就愈发有吸引力。</span><br></pre></td></tr></table></figure>
<p>个人感觉表驱动和策略模式很相似</p>
<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>策略枚举：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OptEnum &#123;</span><br><span class="line">    OPT1(<span class="number">1</span>, <span class="string">"OPT1"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">opt</span><span class="params">(ParamVo param)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"opt1 : do something"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    OPT2(<span class="number">2</span>, <span class="string">"OPT2"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">opt</span><span class="params">(ParamVo param)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"opt2 : do something"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    OPT3(<span class="number">3</span>, <span class="string">"OPT1"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">opt</span><span class="params">(ParamVo param)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"opt3 : do something"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    OptEnum(<span class="keyword">int</span> value, String text) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OptEnum <span class="title">get</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (OptEnum opt : OptEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (opt.getValue() == value)</span><br><span class="line">                <span class="keyword">return</span> opt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">opt</span><span class="params">(ParamVo param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a class="more" href="/box/44b989a/#more">Read more</a><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2019/04/04/5ca58c8caa281.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By warmqing</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script id="ribbon" src="/js/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>